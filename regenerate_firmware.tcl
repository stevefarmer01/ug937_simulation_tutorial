#
#Example Design Directory Tree in Non-Project Mode...
#
#|-- vivado_reports
#|   `-- stuff for building FPGA
#|-- vivado_temp_files
#|   `-- stuff for building FPGA
#|-- simulation_source
#|   `-- spectrum_top_tb.v
#|-- waveform
#|  `-- hw_ila_data_1.wcfg
#`-- sources
#    |-- constraint
#    |  |-- spectrum_top_physical.xdc
#    |  `-- spectrum_top_timing.xdc
#    |-- verilog
#    |  |-- cplx_mult.v
#    |  `-- spectrum_top.v
#    `-- vhdl
#        `-- heartbeat_gen.vhd
#
#
#
# create_bft_batch.tcl
# bft sample design
# A Vivado script that demonstrates a very simple RTL-to-bitstream batch flow
#
# NOTE: typical usage would be "vivado -mode tcl -source create_bft_batch.tcl"
#
# STEP#0: define output directory area.
#

#Part number is set in 'artix_headboard_eval_ip_build_script' so that both modelsim and vivado build/simulate with the same part number
#set part_number xc7a35tcsg325-1

#Create local area to regenerate IP because problems can be cause when pulling repositories with changed IP changing .xci files after reading existing generated files
#Use separate script for IP generation because modelsim needs to regenerate IP too as it contains files required for simulation

#This line does not stop webtalk being sent to Xilinx because we are using a WEBPack license. However, it does stop lots of annoying
#config_webtalk -install off

#This installs a third party tcl app needed for 'xilinx::ultrafast::report_io_reg' command below
#tclapp::install ultrafast

#source vivado_ip_build_script.tcl ### this is now done in

##### vivado -mode batch -source regenerate_firmware.tcl -log vivado_logs/vivado.log -journal vivado_logs/vivado.jou

##### vivado -mode tcl
##### source regenerate_firmware.tcl

set number_of_threads [get_param general.maxThreads]
puts "Max number of threads Vivado 'Implementation' will use = $number_of_threads"
puts "However, Vivado simulation and sythesis will only use 1 as per Multithreading with the Vivado Tools in UG904"
#puts "Press enter"
#gets stdin

#Put xilinx part number in a separate file so that both IP and main code can build from a common part number
source ./fpga_part_number.tcl

set design_top sinegen_demo
set simulation_top testbench

set outputDir ./vivado_reports
set outputDir_prev_run ./vivado_reports_previous_run
file delete -force $outputDir_prev_run
#If this first run then directory "./vivado_reports" will not exist
set dir_exists [file isdirectory $outputDir]
if {$dir_exists == 1} {file copy -force $outputDir $outputDir_prev_run}

file delete -force $outputDir
file mkdir $outputDir

##
## STEP#1: setup design sources and constraints
###
##HDL source


##All vhdl files
read_vhdl -library xil_defaultlib [ glob ./sources/*.vhd ]

set_property top $design_top [get_fileset {sources_1}]
update_compile_order

read_ip [glob ./sources/ip/**/*.xci]
update_ip_catalog -rebuild
report_ip_status


###All verilog files
#read_verilog -library work [ glob ../../../design_definition/hdl/verilog/*.v ]

###common IP source code (could be held in git submodules)
#read_vhdl -library work [ glob ../../../design_definition/hdl/vhdl/common_ip/*.vhd ]
#
###### User IP generated locally by 'regenerate_ip.tcl'
#read_ip [ glob ./${ip_generation_directory}/**/*.xci ]
#
#update_ip_catalog -rebuild
#report_ip_status
#
#
################################################## HLS START #################################################
##Source HLS IP location
#set hls_ip_source_directory ../../../design_definition/vivado_hls
#
##Local IP repository that HLS IP will be uncompressed to
#set regenerate_hls_ip_repo local_hls_ip_repo
##Delete local IP areas which are generated by previous run of this script
#file delete -force $regenerate_hls_ip_repo
#file mkdir $regenerate_hls_ip_repo
##Add local IP area to project
#set_property ip_repo_paths $regenerate_hls_ip_repo [current_fileset]
#update_ip_catalog -rebuild
#
#
##Store original list of IP in current build's repo so that it can be compared after HLS IP added and so difference printed out to screen
#set old_ips [get_ipdefs]
##Add HLS all .zip files generated by /ghdb2/design_definition/vivado_hls/Makefile called by /ghdb2/Synthesis/place_and_route/vivado_non_project_mode/Makefile
#set hls_ip_zips [ glob ${hls_ip_source_directory}/*/*/solution1/impl/ip/*.zip ]
#puts $hls_ip_zips
#foreach hls_ip $hls_ip_zips {
##        puts $hls_ip
#        update_ip_catalog -add_ip $hls_ip -repo_path $regenerate_hls_ip_repo
#}
##Step below may not be needed
##Store new updated list of IP in current build's repo so that it can be compared after HLS IP added and so difference printed out to screen
#set new_ips [get_ipdefs]
##Added HLS IP added and so difference printed out to screen
#puts "############ Custom HLS IP's added to build IP repo....... ############"
## a silly way to get vlnv of the IP added :(
#foreach ip $new_ips {
#    if {[lsearch $old_ips $ip] < 0} {
#        puts $ip
#    }
#}
#
########## Add HLS IP to IP catalogue separately #########
#set_property ip_repo_paths local_hls_ip_repo [current_fileset]
#update_ip_catalog -rebuild
##No HLS IP will now show up in ip_status as it has not been instantiated yet, in this build it will be instantied within the block diagram below (.bd file)
#report_ip_status
################################################## HLS END #################################################
#
#
################################################## BLOCK DIAGRAM START #################################################
########## Add Vivado Block Diagram (this uses HLS IP added above)#########
#read_bd ./project_1/project_1.srcs/sources_1/bd/hls_processing_block_diagram/hls_processing_block_diagram.bd
#
#set_property generate_synth_checkpoint 0 [get_files *.bd]
##break
#
#generate_target all [get_files  ./project_1/project_1.srcs/sources_1/bd/hls_processing_block_diagram/hls_processing_block_diagram.bd]
##Any HLS IP instantiated in block diagram will now show up in ip_status
#update_ip_catalog -rebuild
#report_ip_status
################################################## BLOCK DIAGRAM END #################################################
#
#
####User XDC constraints
#read_xdc ../XilinxM1/physical_7a100_484.xdc
#read_xdc ../XilinxM1/ghdb2_dpmux.xdc
##
#report_compile_order -constraints
##
##
#
#
###
### STEP#2: run synthesis, report utilization and timing estimates, write checkpoint
##design
###
##synth_design -top ${design_top} -part $part_number -flatten rebuilt
##Changed due to setup errors and so as per synth Strategy  = (Vivado Synthesis 2013)
#synth_design -top ${design_top} -part $part_number -flatten rebuilt -control_set_opt_threshold 4
#synth_design -top ${design_top} -part $part_number
#
## Generate reports and design checkpoint
#write_checkpoint -force $outputDir/post_synth
##report_timing -file $outputDir/post_synth_timing.rpt
#report_timing_summary -file $outputDir/post_synth_timing_summary.rpt
#report_power -file $outputDir/post_synth_power.rpt
#
###
### STEP#3: run placement and logic optimization, report utilization and timing
##estimates, write checkpoint design
###
#
##set fp [open ./debug_vivado_runs/post_synth_ports.txt w]
##foreach port_string [get_ports] {puts $fp "$port_string"}
##close $fp
#
##break
#
#opt_design
## power_opt_design             ###### Only do this if needed
#
##place_design
##Below from D Frith's project mode script export (Implementation Strategy = Vivado® Implementation Defaults)
#place_design -directive Explore
#
## phys_opt_design             ###### Only do this if needed
#
## Generate reports and design checkpoint
#write_checkpoint -force $outputDir/post_place
#report_timing_summary -file $outputDir/post_place_timing_summary.rpt
#
###
### STEP#4: run router, report actual utilization and timing, write checkpoint design,
##run drc, write verilog and xdc out
###
#
##route_design
##Below from D Frith's project mode script export (Implementation Strategy = Vivado® Implementation Defaults)
#route_design -directive Explore
#
##place_design -post_place_opt ###### Only do this if needed
##phys_opt_design              ###### Only do this if needed
##route_design                 ###### Only do this if needed
#
## Generate reports and design checkpoint
#write_checkpoint -force $outputDir/post_route
#report_timing_summary -file $outputDir/post_route_timing_summary.rpt -report_unconstrained
#report_timing -sort_by group -max_paths 5 -path_type summary -file $outputDir/post_route_timing.rpt
## report_clock_utilization -file $outputDir/clock_util.rpt
#report_utilization -file $outputDir/post_route_util.rpt
## report_power -file $outputDir/post_route_power.rpt
#report_drc -file $outputDir/post_imp_drc.rpt
## write_verilog -force $outputDir/artix_headboard_impl_netlist.v
## write_xdc -no_fixed_only -force $outputDir/artix_headboard_impl.xdc
#
##### Below is for Vivado 2016.2 only ######
##If below fails ensure that 'UltraFast Design Methodology' is installed via the Vivado TCL store this is as per https://forums.xilinx.com/t5/Welcome-Join/checking-if-registers-are-in-IOB/td-p/707421
##xilinx::ultrafast::report_io_reg -verbose -file $outputDir/post_route_iob.rpt
#
#report_datasheet -file $outputDir/post_route_datasheet.rpt
#report_io -file $outputDir/post_route_io.rpt
#report_clock_utilization -file $outputDir/post_route_clock_util.rpt
#report_clocks -file $outputDir/post_route_report_clock.rpt
#report_clock_interaction -file $outputDir/post_route_clock_interaction.rpt
#report_clock_networks -file $outputDir/post_route_clock_networks.rpt
#report_cdc -file $outputDir/post_route_clock_cdc.rpt
#report_drc -file $outputDir/post_imp_drc.rpt
#report_methodology -file $outputDir/post_imp_methodology_drc.rpt
#
###
### STEP#5: generate a bitstream
###
### Reduce these failures down to warnings to allow bit file to be generated without LOC constaints being applied to pins
##set_property SEVERITY {Warning} [get_drc_checks NSTD-1]
##set_property SEVERITY {Warning} [get_drc_checks UCIO-1]
#
## Reduce these failures down to warnings to allow bit file to be generated without the following error...
##ERROR: [DRC 23-20] Rule violation (LUTLP-1) Combinatorial Loop - 1 LUT cells form a combinatorial loop. This can create a race condition. Timing analysis may not be accurate. The preferred resolution is to modify the design to remove combinatorial logic loops. To allow bitstream creation for designs with combinatorial logic loops (not recommended), use this command: set_property SEVERITY {Warning} [get_drc_checks LUTLP-1]. NOTE: When using the Vivado Runs infrastructure (e.g. launch_runs Tcl command), add this command to a .tcl file and add that file as a pre-hook for write_bitstream step for the implementation run. hls_hbautobal_inst/U0/tointerp_V_write_INST_0.
#set_property SEVERITY {Warning} [get_drc_checks LUTLP-1]
#
#write_bitstream -force -bin_file $outputDir/${design_top}.bit
#write_cfgmem -force -format MCS -size 256 -interface SPIx4 -loadbit "up 0x0 $outputDir/${design_top}.bit" $outputDir/${design_top}_$tcl_platform(platform)
#
######################################
## VIVADO BUILD of FIRMWARE FINISHED #
#######################################
#
###############################################
## START AUTOMATIC VIVADO SIMULATION CREATION
###############################################
#
##Read simulation files
#
##All vhdl files
#read_verilog -library xil_defaultlib [ glob ./sim/*v ]
#read_verilog -library xil_defaultlib [ glob ./sim/*v ]
add_files -fileset [get_fileset sim_1] [ glob ./sim/*.v ]


#set_property USED_IN_SYNTHESIS 0 [get_files ./sim/testbench.v]
#set_property USED_IN_IMPLEMENTATION 0 [get_files ./sim/testbench.v]

##Read packages first manually as when globbed 'export simulation' command seems to do them in alphabetical order (eg those with suffix _pkg afterwards)
#read_vhdl -library work [ glob ../../../design_definition/hdl/vhdl/testbench/multi_array_types_pkg.vhd ]
#read_vhdl -library work [ glob ../../../design_definition/hdl/vhdl/testbench/*_pkg.vhd ]
#read_vhdl -library work [ glob ../../../design_definition/hdl/vhdl/testbench/*.vhd ]
#
#update_compile_order
#
##Force export_simulation command to get simulator to use VHDL IP simulation code
## Unfortunately these 2 'set_property....' lines below appear to cause intermittent simulation failures causing test to 'DID NOT RUN' and giving XSIM error..
##   [XSIM 43-3238] Failed to link the design.
##   ERROR: Please check the snapshot name which is created during 'xelab',the current snapshot name "xsim.dir/ghdb2_dpmux_tb/xsimk.exe" does not exist
##set_property TARGET_LANGUAGE VHDL [current_project]
##set_property SIMULATOR_LANGUAGE VHDL [current_project]
#
##Save project to disk for debuging build scripts to look at synth/impl strategies - this project doesn't find all of it's sources, these may be because it is saved to a subdirectory
set_property top $simulation_top [get_filesets sim_1]
update_compile_order

save_project_as exported_project exported_project -force

#close_project

#open_project ./exported_project/exported_project.xpr

synth_design -top ${design_top} -part $part_number

#launch_simulation -mode post-synthesis -type functional -scripts_only
launch_simulation -mode post-synthesis -type functional
launch_simulation

#save_project_as exported_project exported_project -force


#export_ip_user_files -force
#export_simulation -force -simulator xsim


close_project


#synth_design -top top -part xc7k70tfbg676-2
#open_run synth_1 -name netlist_1
#write_verilog -mode funcsim test_synth.v
#launch_simulation
##### source regenerate_firmware.tcl

#launch_simulation -mode post-synthesis -type functional
#launch_simulation -mode post-synthesis -type functional -simset [get_filesets sim_1]
#
#########################################################################################
## Use export_simulation tcl command to set-up simulation scripts, snapshot, project, etc
#########################################################################################
#
##Vivado 2016.4 needs top to be explicitly declared for export_simulation to work (2016.2 didn't)
#set_property top ghdb2_dpmux_tb [get_filesets sim_1]
#export_ip_user_files -force
#export_simulation -force -simulator xsim
#
##Copy user cmd.tcl over the one generated by export_simulation above so that things like logging all signals can be done
#file copy -force cmd.tcl export_sim/xsim/cmd.tcl
#
#################################################################################
## Update a file to show makefile when this tcl was last performed successfully #
#################################################################################
#
## get the directory where this script resides
#set thisDir [file dirname [info script]]
## source common utilities (touch command)
#source -notrace $thisDir/utils.tcl
## If successful, "touch" a file so the make utility will know it's done
#touch {.regenerate_firmware.done}
